ternary system with 81 size addressable space ?
6
mxxxx : input
1xxxx : output
0xxxx : own/program
/1,3,441,,
registers and program counter also live inside 2xxxx
    can they be moved out of it ?


registers:
- read
- writ
- progP x 2 (op and cte)
- accumulator ? no
- file descriptor ?
    (including io, everything is a file)
- counter : not register but cell modifier.
    used for program and cte

# machine code

Instructions :
- x1 : cte position-,-
- x2 : indirections
- x2 : a choice of 9 operations

An instruction consists in an op and a constant.
cte : cw rc rwc

cw rc rwc y : set swap? dbl_cpy?
cw rc rwc s : sieve split orUnsieve
cw rc rwc S : shake? unShake? shake&
cw rc rwc a : add
cw rc rwc m : min max
cw rc rwc b : tritwise(xor addmod minmax)
cw rc rwc i : inc_dec($r) inc_dec($w) inc_dec($c)
cw? rc? rwc j J : ijmp goto call
    J goto : c->p r->c


PID PFile(r w) fork  toogle clock  halt
    file(create delete) 

spe y : set swap dbl_cpy
spe s : sieve split orUnsieve
spe S : shake unShake shake&
spe a : add, mul?, div mod
spe m : min max
spe b : 
spe i : 
spe j J : toogle clocks ?

desired operations:
addition, subtraction
negation/not 
copy, set
swap, rotns
jumps, cond jump, call
    x3 : p c? pc
    call : if condition (r) reljump c
        and write old positiion to w
min/max
tritwise opn
    add mod, carry borrow
    min/and, max/or
    rot, mirror, keep, discard
    xor (keep, discard, mirror)
fork/spawn
filterSplit and sieve are super cool.
    sieve encompass trit rotations
    particular cases :
    sieve 0 MIN and MAX : are noop.
unsieve ? unsplit (ok add)
ternary opn/ cond swap
inc dec : &$ of rw &$c &io  + fork/swap file c ?
    + &p abs ? halt ?
indir?


# assembly

pbtq C and P

[&$*][rwpc]
RWPC => cte equal to the initial value of &[rwpc]
[&$*] <=> [avi] 
c => directly writing the cte

add5 :
*w += $5
*w += *r

add5 serial :
loop:
noop 
*w += $5
*w += *r
$w += $1
$w swap $r
$w += $1
$w := $C
*w := $loop
$w swap $r


