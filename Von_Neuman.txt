# Design

ternary system with 81 size addressable space ?

oxxxx : own/program
ixxxx : input
lxxxx : output

registers:
- prg : the program head. Initially ooooo,
    meaning the starting instruction is the value at ooooo (*prg).
- stk : the stack head. Initially oiiii.
- aux : an auxiliary register. Initially ollll.
    It is also used for indirections, and io.

- file descriptor ? not readily present on the memory but accessible,
    much like register addreses.
    (including special io, everything is a file)

# Instruction set

Between 0 and 2 trits are used to describe an operand, depending on the operation.
The operation takes up the rest, 2 to 5 trits, provided at most 3 trits are used for operands (1 + 2).

short operand description, usually :
stk[0], prg[0/1], *aux

long operand description, usually :
pop (stk[-1]), emplace (stk[0]), push (stk[1]),
prg, prg[0], prg[1],
aux, *aux, **aux

## Instructions set

### long short (* 27)
? swap

## short short (* 9)

### stk *6
push
pop

## long (* 9)
immediate load (prg[1])

## short (* 3)
get_reg_addr
set_reg_addr # In theory, can be emulated with a combination of get_reg_addr, store, and immediate load
indirection: *aux = **aux, *aux = *prg[1] et stk[0] = **aux

? addto emplace
? addfrom emplace

n * stackreduce : *(stk++) opn *stk |> *stk, *(stk--) opn *stk |> *stk, *stk opn *aux |> *stk
    minus add
    ? mul
    ? div mod
    xor ? addmod
    min max
    trit minmax
    swap
    swap_addr

? neg

call/loop
cond

### fixed operand (* 1) : *stk <- opn *aux *stk
? xor
? addmod
? minus
? neg # would spare a constant and an operation
      # compared to xor lllll, but it might be
      # an intentional constraints to push people
      # to be smart about something simple,
      # keeping lllll around closeby for bulk negation
(prg[1] ?)
sieve
orUnsieve
? split
shake/permut


change_iop # iop long_short ?reversed rw ?failmode
fork
inspect (prg[1])
? 0: halt # could be EoF
? wait # one of the other operation surely is wait
? noop # one of the other operation surely is noop.

? reset registers ?
? launch w default reg ?

## machine code
    Becuase of high reflexivity (VN arch) but low level, the exact
choice of machine code values matters a lot. Ideally, good groupings
should allow for easy manipulation of code using tritwise operations.
In practice, there is also the constraint that we aren't rich in
opcode space.
    The temporary solution is to leave the instruction set up to
debate, and to let advanced players configure (map) their own machine
code (and to use them as inspiration for sensible defaults).

# assembly


- Possibility to anchor the code, to start from anywhere
instead of oiiii.
Syntaxe: like a label but name is a number.
- possibility to enter raw machine code.

## examples
### add5: *liiii = *illll + 5
oiiii: 5
0:
stk |+> -&stk // stk |+> *(--&stk) where the actual variable is &stk, and stk is short for *&stk.
&aux <> &stk
aux |> +&stk // aux |> *(++&stk)


### copy serial: for x in liiii .. lllll, *x = *-x
0:


# completion
input unchanged (no cheating)
input never changed (read only)
never read from outut (write only)
    (*2 ? never used from ouput as rhs
    and never moved info out from output)

? prg constant (reusability)


# score
